#' use `gtsummary` to faster descriptive statistics
#'  a dataframe.In order to reduce the amount of computation, it is
#'  usually necessary to remove very discrete classification variables, such as
#'  patient ID.
#'
#' @param data  a dataframe
#' @param sp_conts  default is null;due to the automatic mechanism of `gtsummary`,
#' this parameter is used to define very discrete continuous variables as
#' continuous variables.
#'
#' @param cate_stat default is "{n} ({p}%)".See [gtsummary::tbl_summary ()] for
#'  more Details.
#' @param cont_stat default is "{mean} ({sd})".See [gtsummary::tbl_summary ()]
#' for more Details.
#'
#' @return
#'   gtsummary$table_body
#'
#' @export
#' @examples
#' \dontrun{
#' data(data_med)
#' lab_wider = data_med$lab  %>%
#'   tr(.,c("test_date"),"dat") %>%
#'   group_by(patient_id,lab_name) %>%
#'   arrange(test_date) %>%  slice_tail(n =1) %>%  ungroup() %>%
#'   select(patient_id,lab_name ,lab_va) %>%
#'   tr(.,c("lab_va"),"num") %>%
#'   spread(lab_name,lab_va) %>%  distinct()
#'
#' HbA1c <- c(0,6.5,7.0,8.0,9.0,Inf)
#' TC <- c(0,5.2,6.2,Inf)
#' LDL <- c(0,3.4,4.1,Inf)
#' HDL <- c(0,1.0,Inf)
#' TG <- c(0,1.7,2.3,Inf)
#' WBC <- c(0,4,10,Inf)
#' #'
#' ## keep only the columns related to the analysis
#' lib_name_list <- names(lab_wider)[-1]
#' ## this step need to adjust the order of list subsets in name_list order
#' list_cut <- list(HbA1c,HDL,LDL,TC,TG,WBC)
#' ## mutate multiple split variable columns
#' lab_wider_cut = mmc(lab_wider,lib_name_list,list_cut,digits=2)
#' ## Add a missing data to fully demonstrate the function of the function
#' lab_wider_cut = lab_wider_cut %>%
#'   rbind(.,
#'         matrix(NA,nrow = 1,ncol =dim(lab_wider_cut)[2]) %>% data.frame() %>%
#'           rename_at(vars(names(.)) ,~ names(lab_wider_cut)) ) %>%
#'   mutate(patient_id = replace_na(patient_id, "test_id"))
#'
#' ## faster descriptive statistics.
#' data_lab_calcu <- calcu(lab_wider_cut[,-1],names(lab_wider)[-1])
#'}
#'
calcu <- function(data,sp_conts=NULL,cate_stat = "{n} ({p}%)",
                      cont_stat ="{mean} ({sd})" ){
  listtype = if(is.null(sp_conts)){
    list(all_categorical() ~ "categorical",all_continuous() ~ "continuous2")
  }else{
    list(all_categorical() ~ "categorical",sp_conts ~ "continuous2")}

  temp <- data  %>% tbl_summary(
    statistic = list(all_categorical() ~ cate_stat,
                     all_continuous() ~ cont_stat),
    type = listtype,
    digits = list(all_continuous() ~ 2,
                  all_categorical() ~ c(0, 2)),
    missing_text = "Miss") %>%
    modify_header(label = "")
  return(temp$table_body)
}




#' Extract the statistical summary generated by `calcu` for continuous data
#'
#' Parse the statistical summary generated by `calcu` and generate the statistical
#' results in standard format
#'
#'
#' @param gt_table_body result of `calcu` calculation.
#' @param aim_name extract the specified column name.
#' @param ifmiss whether to retain the missing value in the output result,default
#'     is `FALSE`.
#' @param ppop default is `NULL`. `gt_table_body` come from a subset of the
#' total population? If you need to calculate the statistics of the subset in the
#' total population, please provide a total population.
#'
#' @param iftest default is `TRUE`.Provide the proportion of the subset of patients
#'  to the total number of people, similar to the statistics of the number of
#'  patients in biochemical tests.
#'
#' @return
#'     A structured data set.A structured dataset. Contains the average and
#'     proportion of continuous variables, as well as the number and proportion
#'     of subsets after the classification of continuous variables.
#' @export
#'
#' @examples
#' \dontrun{
#' data(data_med)
#'
#' lab_wider = data_med$lab  %>%
#'   tr(.,c("test_date"),"dat") %>%
#'   group_by(patient_id,lab_name) %>%
#'   arrange(test_date) %>%  slice_tail(n =1) %>%  ungroup() %>%
#'   select(patient_id,lab_name ,lab_va) %>%
#'   tr(.,c("lab_va"),"num") %>%
#'   spread(lab_name,lab_va) %>%  distinct()
#'
#' HbA1c <- c(0,6.5,7.0,8.0,9.0,Inf)
#' TC <- c(0,5.2,6.2,Inf)
#' LDL <- c(0,3.4,4.1,Inf)
#' HDL <- c(0,1.0,Inf)
#' TG <- c(0,1.7,2.3,Inf)
#' WBC <- c(0,4,10,Inf)
#'
#' ## keep only the columns related to the analysis
#' lib_name_list <- names(lab_wider)[-1]
#' ## this step need to adjust the order of list subsets in name_list order
#' list_cut <- list(HbA1c,HDL,LDL,TC,TG,WBC)
#' ## mutate multiple split variable columns
#' lab_wider_cut = mmc(lab_wider,lib_name_list,list_cut,digits=2)
#' ## Add a missing data to fully demonstrate the function of the function
#' lab_wider_cut = lab_wider_cut %>%
#'   rbind(.,
#'         matrix(NA,nrow = 1,ncol =dim(lab_wider_cut)[2]) %>% data.frame() %>%
#'           rename_at(vars(names(.)) ,~ names(lab_wider_cut)) ) %>%
#'   mutate(patient_id = replace_na(patient_id, "test_id"))
#'
#' ## faster descriptive statistics.
#' data_lab_calcu <- calcu(lab_wider_cut[,-1],names(lab_wider)[-1])
#'
#' ## Statistical results of a single indicator
#' bind_cut_cont_test = bind_cut_cont(data_lab_calcu,"HbA1c")
#'
#' ## Statistical results of multiple indicators
#' purrr::map_df(lib_name_list,bind_cut_cont,
#'               gt_table_body = data_lab_calcu,ppop=100)
#'}
bind_cut_cont  <- function(gt_table_body,aim_name,
                           ifmiss = FALSE,ppop=NULL,iftest =TRUE){
  gt_table_body = data_lab_calcu
  aim_name = 'HbA1c'
  cut_na <- paste0(aim_name,"_cut")

  ## Extract mean and sd;
  t1 <- gt_table_body %>%
    subset("var_label" == aim_name ) %>%
    subset("label" == "Mean (SD)",select = "stat_0" ) %>%
    separate("stat_0",into = c("Mean","SD"),sep = " ",remove = T) %>%
    mutate(SD2 =  gsub(".*\\(|\\).*","", SD)) %>%
    select(!SD) %>% rename(SD = SD2) %>%
    mutate(label = paste0(aim_name,"[mean(sd)] "),.before="Mean")

  ## Insert a blank line
  t2 <- gt_table_body %>%
    subset("variable" == cut_na,select = c("stat_0")) %>%
    slice(1) %>%
    separate("stat_0",into = c("Mean","SD"),sep = "",remove = T) %>%
    mutate(label = paste0(cut_na, "[num(prop)]"),.before = "Mean")

  ## Extract number and proportion
  t3 <- gt_table_body %>%
    subset("variable" == cut_na,select = c("label","stat_0" )) %>%
    slice(-1)  %>%
    separate("stat_0",into = c("Mean","SD"),sep = " ",remove = T) %>%
    mutate(Mean = sub(pattern = ",",replacement = "",.$Mean)) %>%
    mutate(across(.cols = c(Mean), .fns = as.numeric)) %>%
    mutate(SD = paste0(format(round(Mean/sum(Mean), 4)*100,nsmall=2), "%", sep=""))

  ##
  if(ifmiss == FALSE & is.null(ppop)){
    t3_clean = t3 %>% filter(!label == "Miss")
  }else if(ifmiss == TRUE & is.null(ppop)){
    t3_clean = t3
  }else if(ifmiss == FALSE & !is.null(ppop)){
    t3_clean = t3 %>% filter(!label == "Miss") %>%
      mutate(SD = paste0(format(round(Mean/ppop, 4)*100,nsmall=2), "%", sep=""))
  }else{
    t3_clean = t3 %>%
      mutate(SD = paste0(format(round(Mean/ppop, 4)*100,nsmall=2), "%", sep=""))
  }

  ## Number of people inspected
  if("Miss" %in% t3$label & !is.null(ppop) ){
    t4 = t3 %>%
      filter(label == "Miss") %>%
      mutate(label = paste0(aim_name,"_test[num(prop)]"),
             Mean = (sum(t3$Mean) - .$Mean),
             SD = paste0(format(round(Mean/ppop, 4)*100,nsmall=2), "%", sep=""))
  }else if("Miss" %in% t3$label & is.null(ppop)){
    t4 = t3 %>%
      filter(label == "Miss") %>%
      mutate(label = paste0(aim_name,"_test[num(prop)]"),
             Mean = (sum(t3$Mean) - .$Mean),
             SD = paste0(format(round(Mean/sum(t3$Mean), 4)*100,nsmall=2), "%", sep=""))
  }else if(!"Miss" %in% t3$label & is.null(ppop)){
    t4 = t2  %>%
      mutate(label = paste0(aim_name,"_test[num(prop)]"),
             Mean = dim(data)[1],
             SD= "100%")
  }else{
    t4 = t2  %>%
      mutate(label = paste0(aim_name,"_test[num(prop)]"),
             Mean = dim(data)[1],
             SD= paste0(format(round(Mean/ppop, 4)*100,nsmall=2), "%", sep=""))
  }

 if(iftest == TRUE){rbind(t4,t1,t2,t3_clean)}else{rbind(t1,t2,t3_clean)}

}



#' Extract the statistical summary generated by `calcu` for classified data
#'
#' @note When the parameter `ppop` is provided, only the parameter `ppop` is used by default to
#' calculate the `group_list`. So please redesign the running rules, or use `? bind_cut_ cate` to
#' view the internal build logic of the function to redesign the code.
#'
#' @param gt_table_body result of `calcu` calculation.
#'
#' @param group_list need to provide a specified column name, which is usually
#'  a basic diagnosis or drug list.
#'
#' @param merge_subgroup_name  default is `NULL`.Need to provide the specified column name, which
#' is generally the collective term of basic diagnosis or basic drugs.If this parameter provides a
#' non-NULL character, then `group_ list` will be regarded as a subset of the diagnosis or drug,
#' and its corresponding percentage will also be used as the denominator.
#'
#' @param ppop default is `NULL`. `gt_table_body` come from a subset of the
#' total population? If you need to calculate the statistics of the subset in the
#' total population, please provide a total population.
#'
#' @return
#'     A structured data set.A structured dataset. Contains the number and proportion
#'     of subsets after the classification of classified variables.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' data(data_med)
#' diags = data_med$diag
#' aim_select = c("patient_id","visit_id","diag_union")
#'
#' diag_wider = wider_clean(diags,aim_select)
#'
#' diag_wider_calcu = diag_wider %>% select(!"patient_id") %>%
#'   dplyr::mutate("vascular disease" =1) %>% calcu(.)
#'
#' group_list = c("Dyslipidemia","high blood pressure","myocardial infarction")
#' merge_subgroup_name = "vascular disease"
#' #'
#' bind_cut_cate(diag_wider_calcu,group_list,merge_subgroup_name)
#' bind_cut_cate(diag_wider_calcu,group_list,ppop=1000)
#'}
bind_cut_cate = function(gt_table_body,
                         group_list,
                         merge_subgroup_name=NULL,ppop=NULL){
  test_check = merge_subgroup_name
  if((!is.null(test_check) & length(test_check)>1) |
     (!is.null(test_check) & unique(gt_table_body$variable %in% test_check)))
    stop("check `merge_subgroup_name`")

    extract <- function(data,aim_name){
      data %>% filter(variable %in% aim_name) %>% select("label","stat_0" ) %>%
        filter(label ==1) %>%
        separate("stat_0",into = c("Mean","SD"), sep = " ",remove = T) %>%
        mutate(SD = gsub(".*\\(|\\).*","", SD)) %>%
        mutate(label = paste0(aim_name,"[pop(prop)]"),.before = label)
    }
    subgroup_list_stat <- purrr::map_df(group_list,extract,data = gt_table_body) %>%
      tr(.,"Mean","num")

    if(!is.null(merge_subgroup_name)){
      merge_subgroup_stat = extract(gt_table_body,aim_name=merge_subgroup_name) %>%
        tr(.,"Mean","num")
      subgroup_list_stat_update = subgroup_list_stat %>%
        mutate(SD = paste0(format(round(Mean/merge_subgroup_stat$Mean, 4)*100,nsmall=2), "%", sep=""))
      out = rbind(merge_subgroup_stat,subgroup_list_stat_update)
    }else{
      merge_subgroup_stat = extract(gt_table_body,aim_name=merge_subgroup_name)
      out = rbind(merge_subgroup_stat,subgroup_list_stat)
    }

    if(!is.null(ppop) & !is.null(merge_subgroup_name)){
      warning("When the parameter `ppop` is provided, only the parameter `ppop` is \n
      used by default to calculate the `group_list`. So please redesign the running rules,\n
      or use `?bind_cut_cate` to view the internal build logic of the function to redesign the code")
    }else if(is.null(ppop) & !is.null(merge_subgroup_name)){
      return(out)
    }else{
      out_calcu = out %>%
        tr(.,"Mean","num") %>%
        mutate(SD = paste0(format(round(Mean/ppop, 4)*100,nsmall=2), "%", sep=""))
      return(out_calcu)
    }
}




